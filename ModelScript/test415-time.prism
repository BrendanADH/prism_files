mdp

const grid_size = 5;
const num_robots = 4;

const bool X1Y1_Occupied = false;
const bool X1Y2_Occupied = false;
const bool X1Y3_Occupied = false;
const bool X1Y4_Occupied = false;
const bool X1Y5_Occupied = false;
const bool X2Y1_Occupied = false;
const bool X2Y2_Occupied = false;
const bool X2Y3_Occupied = false;
const bool X2Y4_Occupied = false;
const bool X2Y5_Occupied = false;
const bool X3Y1_Occupied = false;
const bool X3Y2_Occupied = false;
const bool X3Y3_Occupied = false;
const bool X3Y4_Occupied = false;
const bool X3Y5_Occupied = false;
const bool X4Y1_Occupied = false;
const bool X4Y2_Occupied = false;
const bool X4Y3_Occupied = false;
const bool X4Y4_Occupied = false;
const bool X4Y5_Occupied = false;
const bool X5Y1_Occupied = false;
const bool X5Y2_Occupied = false;
const bool X5Y3_Occupied = false;
const bool X5Y4_Occupied = false;
const bool X5Y5_Occupied = false;

formula obstacleLeftR0 = (x0 = 2 & y0 = 1 & X1Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X1Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 3 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR0 = (x0 = 1 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 1 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 1 & y0 = 3 & X2Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X3Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X3Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR0 = (x0 = 1 & y0 = 2 & X1Y1_Occupied = true)|(x0 = 1 & y0 = 3 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y1_Occupied = true)|(x0 = 2 & y0 = 3 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y1_Occupied = true)|(x0 = 3 & y0 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR0 = (x0 = 1 & y0 = 1 & X1Y2_Occupied = true)|(x0 = 1 & y0 = 2 & X1Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X2Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X3Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y3_Occupied = true);

module robot0

	R0Lock : bool; // lock for clock sync
	x0 : [1..grid_size]; // location variables
	y0 : [1..grid_size];

	[release] R0Lock = true -> (R0Lock'=false); // release lock according to the sync module
	[R0Move] !R0Lock & x0>1 & !obstacleLeftR0-> (x0'=x0-1) & (R0Lock' = true); // left 
	[R0Move] !R0Lock & x0<grid_size & !obstacleRightR0-> (x0'=x0+1) & (R0Lock' = true); // right 
	[R0Move] !R0Lock & y0>1 & !obstacleDownR0-> (y0'=y0-1) & (R0Lock' = true); // down 
	[R0Move] !R0Lock & y0<grid_size & !obstacleUpR0-> (y0'=y0+1) & (R0Lock' = true); // up 

	[R0Wait] !R0Lock -> (R0Lock' = true); // wait

	[T0R0Complete] R0Lock & T0Active=true & x0=tx0 & y0=ty0-> (R0Lock' = true);

endmodule

formula obstacleLeftR1 = (x1 = 2 & y1 = 1 & X1Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X1Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 3 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR1 = (x1 = 1 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 1 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 1 & y1 = 3 & X2Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X3Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X3Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR1 = (x1 = 1 & y1 = 2 & X1Y1_Occupied = true)|(x1 = 1 & y1 = 3 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y1_Occupied = true)|(x1 = 2 & y1 = 3 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y1_Occupied = true)|(x1 = 3 & y1 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR1 = (x1 = 1 & y1 = 1 & X1Y2_Occupied = true)|(x1 = 1 & y1 = 2 & X1Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X2Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X3Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y3_Occupied = true);

module robot1

	R1Lock : bool; // lock for clock sync
	x1 : [1..grid_size]; // location variables
	y1 : [1..grid_size];

	[release] R1Lock = true -> (R1Lock'=false); // release lock according to the sync module
	[R1Move] !R1Lock & x1>1 & !obstacleLeftR1-> (x1'=x1-1) & (R1Lock' = true); // left 
	[R1Move] !R1Lock & x1<grid_size & !obstacleRightR1-> (x1'=x1+1) & (R1Lock' = true); // right 
	[R1Move] !R1Lock & y1>1 & !obstacleDownR1-> (y1'=y1-1) & (R1Lock' = true); // down 
	[R1Move] !R1Lock & y1<grid_size & !obstacleUpR1-> (y1'=y1+1) & (R1Lock' = true); // up 

	[R1Wait] !R1Lock -> (R1Lock' = true); // wait

	[T0R1Complete] R1Lock & T0Active=true & x1=tx0 & y1=ty0-> (R1Lock' = true);

endmodule

formula obstacleLeftR2 = (x2 = 2 & y2 = 1 & X1Y1_Occupied = true)|(x2 = 2 & y2 = 2 & X1Y2_Occupied = true)|(x2 = 2 & y2 = 3 & X1Y3_Occupied = true)|(x2 = 3 & y2 = 1 & X2Y1_Occupied = true)|(x2 = 3 & y2 = 2 & X2Y2_Occupied = true)|(x2 = 3 & y2 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR2 = (x2 = 1 & y2 = 1 & X2Y1_Occupied = true)|(x2 = 1 & y2 = 2 & X2Y2_Occupied = true)|(x2 = 1 & y2 = 3 & X2Y3_Occupied = true)|(x2 = 2 & y2 = 1 & X3Y1_Occupied = true)|(x2 = 2 & y2 = 2 & X3Y2_Occupied = true)|(x2 = 2 & y2 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR2 = (x2 = 1 & y2 = 2 & X1Y1_Occupied = true)|(x2 = 1 & y2 = 3 & X1Y2_Occupied = true)|(x2 = 2 & y2 = 2 & X2Y1_Occupied = true)|(x2 = 2 & y2 = 3 & X2Y2_Occupied = true)|(x2 = 3 & y2 = 2 & X3Y1_Occupied = true)|(x2 = 3 & y2 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR2 = (x2 = 1 & y2 = 1 & X1Y2_Occupied = true)|(x2 = 1 & y2 = 2 & X1Y3_Occupied = true)|(x2 = 2 & y2 = 1 & X2Y2_Occupied = true)|(x2 = 2 & y2 = 2 & X2Y3_Occupied = true)|(x2 = 3 & y2 = 1 & X3Y2_Occupied = true)|(x2 = 3 & y2 = 2 & X3Y3_Occupied = true);

module robot2

	R2Lock : bool; // lock for clock sync
	x2 : [1..grid_size]; // location variables
	y2 : [1..grid_size];

	[release] R2Lock = true -> (R2Lock'=false); // release lock according to the sync module
	[R2Move] !R2Lock & x2>1 & !obstacleLeftR2-> (x2'=x2-1) & (R2Lock' = true); // left 
	[R2Move] !R2Lock & x2<grid_size & !obstacleRightR2-> (x2'=x2+1) & (R2Lock' = true); // right 
	[R2Move] !R2Lock & y2>1 & !obstacleDownR2-> (y2'=y2-1) & (R2Lock' = true); // down 
	[R2Move] !R2Lock & y2<grid_size & !obstacleUpR2-> (y2'=y2+1) & (R2Lock' = true); // up 

	[R2Wait] !R2Lock -> (R2Lock' = true); // wait

	[T0R2Complete] R2Lock & T0Active=true & x2=tx0 & y2=ty0-> (R2Lock' = true);

endmodule

formula obstacleLeftR3 = (x3 = 2 & y3 = 1 & X1Y1_Occupied = true)|(x3 = 2 & y3 = 2 & X1Y2_Occupied = true)|(x3 = 2 & y3 = 3 & X1Y3_Occupied = true)|(x3 = 3 & y3 = 1 & X2Y1_Occupied = true)|(x3 = 3 & y3 = 2 & X2Y2_Occupied = true)|(x3 = 3 & y3 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR3 = (x3 = 1 & y3 = 1 & X2Y1_Occupied = true)|(x3 = 1 & y3 = 2 & X2Y2_Occupied = true)|(x3 = 1 & y3 = 3 & X2Y3_Occupied = true)|(x3 = 2 & y3 = 1 & X3Y1_Occupied = true)|(x3 = 2 & y3 = 2 & X3Y2_Occupied = true)|(x3 = 2 & y3 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR3 = (x3 = 1 & y3 = 2 & X1Y1_Occupied = true)|(x3 = 1 & y3 = 3 & X1Y2_Occupied = true)|(x3 = 2 & y3 = 2 & X2Y1_Occupied = true)|(x3 = 2 & y3 = 3 & X2Y2_Occupied = true)|(x3 = 3 & y3 = 2 & X3Y1_Occupied = true)|(x3 = 3 & y3 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR3 = (x3 = 1 & y3 = 1 & X1Y2_Occupied = true)|(x3 = 1 & y3 = 2 & X1Y3_Occupied = true)|(x3 = 2 & y3 = 1 & X2Y2_Occupied = true)|(x3 = 2 & y3 = 2 & X2Y3_Occupied = true)|(x3 = 3 & y3 = 1 & X3Y2_Occupied = true)|(x3 = 3 & y3 = 2 & X3Y3_Occupied = true);

module robot3

	R3Lock : bool; // lock for clock sync
	x3 : [1..grid_size]; // location variables
	y3 : [1..grid_size];

	[release] R3Lock = true -> (R3Lock'=false); // release lock according to the sync module
	[R3Move] !R3Lock & x3>1 & !obstacleLeftR3-> (x3'=x3-1) & (R3Lock' = true); // left 
	[R3Move] !R3Lock & x3<grid_size & !obstacleRightR3-> (x3'=x3+1) & (R3Lock' = true); // right 
	[R3Move] !R3Lock & y3>1 & !obstacleDownR3-> (y3'=y3-1) & (R3Lock' = true); // down 
	[R3Move] !R3Lock & y3<grid_size & !obstacleUpR3-> (y3'=y3+1) & (R3Lock' = true); // up 

	[R3Wait] !R3Lock -> (R3Lock' = true); // wait

	[T0R3Complete] R3Lock & T0Active=true & x3=tx0 & y3=ty0-> (R3Lock' = true);

endmodule

module task0

	T0Active : bool;
	tx0 : [1..grid_size];
	ty0 : [1..grid_size];

	[T0R0Complete] T0Active=true & x0=tx0 & y0=ty0 -> (T0Active' = false);
	[T0R1Complete] T0Active=true & x1=tx0 & y1=ty0 -> (T0Active' = false);
	[T0R2Complete] T0Active=true & x2=tx0 & y2=ty0 -> (T0Active' = false);
	[T0R3Complete] T0Active=true & x3=tx0 & y3=ty0 -> (T0Active' = false);

endmodule

formula all_robots_complete = (R0Lock & R1Lock & R2Lock & R3Lock);

module sync

	[release] all_robots_complete -> true;

endmodule

rewards "time"

	[release] true: 1;

endrewards

init

	R0Lock = false &
	R1Lock = false &
	R2Lock = false &
	R3Lock = false &
	T0Active = true 

endinit