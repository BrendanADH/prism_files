mdp

const grid_size = 5;
const num_robots = 3;

const bool X1Y1_Occupied = false;
const bool X1Y2_Occupied = false;
const bool X1Y3_Occupied = false;
const bool X1Y4_Occupied = false;
const bool X1Y5_Occupied = false;
const bool X2Y1_Occupied = false;
const bool X2Y2_Occupied = false;
const bool X2Y3_Occupied = false;
const bool X2Y4_Occupied = false;
const bool X2Y5_Occupied = false;
const bool X3Y1_Occupied = false;
const bool X3Y2_Occupied = false;
const bool X3Y3_Occupied = false;
const bool X3Y4_Occupied = false;
const bool X3Y5_Occupied = false;
const bool X4Y1_Occupied = false;
const bool X4Y2_Occupied = false;
const bool X4Y3_Occupied = false;
const bool X4Y4_Occupied = false;
const bool X4Y5_Occupied = false;
const bool X5Y1_Occupied = false;
const bool X5Y2_Occupied = false;
const bool X5Y3_Occupied = false;
const bool X5Y4_Occupied = false;
const bool X5Y5_Occupied = false;

formula obstacleLeftR0 = (x0 = 2 & y0 = 1 & X1Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X1Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 3 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR0 = (x0 = 1 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 1 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 1 & y0 = 3 & X2Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X3Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X3Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR0 = (x0 = 1 & y0 = 2 & X1Y1_Occupied = true)|(x0 = 1 & y0 = 3 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y1_Occupied = true)|(x0 = 2 & y0 = 3 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y1_Occupied = true)|(x0 = 3 & y0 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR0 = (x0 = 1 & y0 = 1 & X1Y2_Occupied = true)|(x0 = 1 & y0 = 2 & X1Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X2Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X3Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y3_Occupied = true);

module robot0

	R0Lock : bool; // lock for clock sync
	x0 : [1..grid_size]; // location variables
	y0 : [1..grid_size];

	[release] R0Lock = true -> (R0Lock'=false); // release lock according to the sync module
	[R0Move] active_bot = 0 & !R0Lock & x0>1 & !obstacleLeftR0-> (x0'=x0-1) & (R0Lock' = true); // left 
	[R0Move] active_bot = 0 & !R0Lock & x0<grid_size & !obstacleRightR0-> (x0'=x0+1) & (R0Lock' = true); // right 
	[R0Move] active_bot = 0 & !R0Lock & y0>1 & !obstacleDownR0-> (y0'=y0-1) & (R0Lock' = true); // down 
	[R0Move] active_bot = 0 & !R0Lock & y0<grid_size & !obstacleUpR0-> (y0'=y0+1) & (R0Lock' = true); // up 

	[R0Wait] active_bot = 0 & !R0Lock -> (R0Lock' = true); // wait

	[T0R0Complete] active_bot = 0 & !R0Lock & T0Active=true & x0=tx0 & y0=ty0-> (R0Lock' = true);

endmodule

formula obstacleLeftR1 = (x1 = 2 & y1 = 1 & X1Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X1Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 3 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR1 = (x1 = 1 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 1 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 1 & y1 = 3 & X2Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X3Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X3Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR1 = (x1 = 1 & y1 = 2 & X1Y1_Occupied = true)|(x1 = 1 & y1 = 3 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y1_Occupied = true)|(x1 = 2 & y1 = 3 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y1_Occupied = true)|(x1 = 3 & y1 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR1 = (x1 = 1 & y1 = 1 & X1Y2_Occupied = true)|(x1 = 1 & y1 = 2 & X1Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X2Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X3Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y3_Occupied = true);

module robot1

	R1Lock : bool; // lock for clock sync
	x1 : [1..grid_size]; // location variables
	y1 : [1..grid_size];

	[release] R1Lock = true -> (R1Lock'=false); // release lock according to the sync module
	[R1Move] active_bot = 1 & !R1Lock & x1>1 & !obstacleLeftR1-> (x1'=x1-1) & (R1Lock' = true); // left 
	[R1Move] active_bot = 1 & !R1Lock & x1<grid_size & !obstacleRightR1-> (x1'=x1+1) & (R1Lock' = true); // right 
	[R1Move] active_bot = 1 & !R1Lock & y1>1 & !obstacleDownR1-> (y1'=y1-1) & (R1Lock' = true); // down 
	[R1Move] active_bot = 1 & !R1Lock & y1<grid_size & !obstacleUpR1-> (y1'=y1+1) & (R1Lock' = true); // up 

	[R1Wait] active_bot = 1 & !R1Lock -> (R1Lock' = true); // wait

	[T0R1Complete] active_bot = 1 & !R1Lock & T0Active=true & x1=tx0 & y1=ty0-> (R1Lock' = true);

endmodule

formula obstacleLeftR2 = (x2 = 2 & y2 = 1 & X1Y1_Occupied = true)|(x2 = 2 & y2 = 2 & X1Y2_Occupied = true)|(x2 = 2 & y2 = 3 & X1Y3_Occupied = true)|(x2 = 3 & y2 = 1 & X2Y1_Occupied = true)|(x2 = 3 & y2 = 2 & X2Y2_Occupied = true)|(x2 = 3 & y2 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR2 = (x2 = 1 & y2 = 1 & X2Y1_Occupied = true)|(x2 = 1 & y2 = 2 & X2Y2_Occupied = true)|(x2 = 1 & y2 = 3 & X2Y3_Occupied = true)|(x2 = 2 & y2 = 1 & X3Y1_Occupied = true)|(x2 = 2 & y2 = 2 & X3Y2_Occupied = true)|(x2 = 2 & y2 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR2 = (x2 = 1 & y2 = 2 & X1Y1_Occupied = true)|(x2 = 1 & y2 = 3 & X1Y2_Occupied = true)|(x2 = 2 & y2 = 2 & X2Y1_Occupied = true)|(x2 = 2 & y2 = 3 & X2Y2_Occupied = true)|(x2 = 3 & y2 = 2 & X3Y1_Occupied = true)|(x2 = 3 & y2 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR2 = (x2 = 1 & y2 = 1 & X1Y2_Occupied = true)|(x2 = 1 & y2 = 2 & X1Y3_Occupied = true)|(x2 = 2 & y2 = 1 & X2Y2_Occupied = true)|(x2 = 2 & y2 = 2 & X2Y3_Occupied = true)|(x2 = 3 & y2 = 1 & X3Y2_Occupied = true)|(x2 = 3 & y2 = 2 & X3Y3_Occupied = true);

module robot2

	R2Lock : bool; // lock for clock sync
	x2 : [1..grid_size]; // location variables
	y2 : [1..grid_size];

	[release] R2Lock = true -> (R2Lock'=false); // release lock according to the sync module
	[R2Move] active_bot = 2 & !R2Lock & x2>1 & !obstacleLeftR2-> (x2'=x2-1) & (R2Lock' = true); // left 
	[R2Move] active_bot = 2 & !R2Lock & x2<grid_size & !obstacleRightR2-> (x2'=x2+1) & (R2Lock' = true); // right 
	[R2Move] active_bot = 2 & !R2Lock & y2>1 & !obstacleDownR2-> (y2'=y2-1) & (R2Lock' = true); // down 
	[R2Move] active_bot = 2 & !R2Lock & y2<grid_size & !obstacleUpR2-> (y2'=y2+1) & (R2Lock' = true); // up 

	[R2Wait] active_bot = 2 & !R2Lock -> (R2Lock' = true); // wait

	[T0R2Complete] active_bot = 2 & !R2Lock & T0Active=true & x2=tx0 & y2=ty0-> (R2Lock' = true);

endmodule

module task0

	T0Active : bool;
	tx0 : [1..grid_size];
	ty0 : [1..grid_size];

	[T0R0Complete] T0Active=true & x0=tx0 & y0=ty0 -> (T0Active' = false);
	[T0R1Complete] T0Active=true & x1=tx0 & y1=ty0 -> (T0Active' = false);
	[T0R2Complete] T0Active=true & x2=tx0 & y2=ty0 -> (T0Active' = false);

endmodule

module sync

	active_bot : [0..num_robots];

	[release] active_bot = num_robots -> (active_bot'=0);

	[R0Move] true -> (active_bot' = min(active_bot+1, num_robots));
	[R0Wait] true -> (active_bot' = min(active_bot+1, num_robots));
	[R1Move] true -> (active_bot' = min(active_bot+1, num_robots));
	[R1Wait] true -> (active_bot' = min(active_bot+1, num_robots));
	[R2Move] true -> (active_bot' = min(active_bot+1, num_robots));
	[R2Wait] true -> (active_bot' = min(active_bot+1, num_robots));

	[T0R0Complete] true -> (active_bot' = min(active_bot+1, num_robots));
	[T0R1Complete] true -> (active_bot' = min(active_bot+1, num_robots));
	[T0R2Complete] true -> (active_bot' = min(active_bot+1, num_robots));

endmodule

rewards "time"

	[release] true: 1;

endrewards

init

	R0Lock = false &
	R1Lock = false &
	R2Lock = false &
	T0Active = true &
	active_bot = 0 &	
	tx0 = 2 &
	ty0 = 1
	

endinit