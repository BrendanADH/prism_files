mdp

const grid_size = 5;
const num_robots = 2;

const bool X1Y1_Occupied = false;
const bool X1Y2_Occupied = false;
const bool X1Y3_Occupied = false;
const bool X1Y4_Occupied = false;
const bool X1Y5_Occupied = false;
const bool X2Y1_Occupied = false;
const bool X2Y2_Occupied = false;
const bool X2Y3_Occupied = false;
const bool X2Y4_Occupied = false;
const bool X2Y5_Occupied = false;
const bool X3Y1_Occupied = false;
const bool X3Y2_Occupied = false;
const bool X3Y3_Occupied = false;
const bool X3Y4_Occupied = false;
const bool X3Y5_Occupied = false;
const bool X4Y1_Occupied = false;
const bool X4Y2_Occupied = false;
const bool X4Y3_Occupied = false;
const bool X4Y4_Occupied = false;
const bool X4Y5_Occupied = false;
const bool X5Y1_Occupied = false;
const bool X5Y2_Occupied = false;
const bool X5Y3_Occupied = false;
const bool X5Y4_Occupied = false;
const bool X5Y5_Occupied = false;

formula obstacleLeftR0 = (x0 = 2 & y0 = 1 & X1Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X1Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 3 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR0 = (x0 = 1 & y0 = 1 & X2Y1_Occupied = true)|(x0 = 1 & y0 = 2 & X2Y2_Occupied = true)|(x0 = 1 & y0 = 3 & X2Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X3Y1_Occupied = true)|(x0 = 2 & y0 = 2 & X3Y2_Occupied = true)|(x0 = 2 & y0 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR0 = (x0 = 1 & y0 = 2 & X1Y1_Occupied = true)|(x0 = 1 & y0 = 3 & X1Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y1_Occupied = true)|(x0 = 2 & y0 = 3 & X2Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y1_Occupied = true)|(x0 = 3 & y0 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR0 = (x0 = 1 & y0 = 1 & X1Y2_Occupied = true)|(x0 = 1 & y0 = 2 & X1Y3_Occupied = true)|(x0 = 2 & y0 = 1 & X2Y2_Occupied = true)|(x0 = 2 & y0 = 2 & X2Y3_Occupied = true)|(x0 = 3 & y0 = 1 & X3Y2_Occupied = true)|(x0 = 3 & y0 = 2 & X3Y3_Occupied = true);

module robot0

	R0Lock : bool; // lock for clock sync
	x0 : [1..grid_size]; // location variables
	y0 : [1..grid_size];

	[release] R0Lock = true -> (R0Lock'=false); // release lock according to the sync module
	[R0Move] !R0Lock & x0>1 & !obstacleLeftR0-> (x0'=x0-1) & (R0Lock' = true); // left 
	[R0Move] !R0Lock & x0<grid_size & !obstacleRightR0-> (x0'=x0+1) & (R0Lock' = true); // right 
	[R0Move] !R0Lock & y0>1 & !obstacleDownR0-> (y0'=y0-1) & (R0Lock' = true); // down 
	[R0Move] !R0Lock & y0<grid_size & !obstacleUpR0-> (y0'=y0+1) & (R0Lock' = true); // up 

	[R0Wait] !R0Lock -> (R0Lock' = true); // wait

	[T0R0Complete] R0Lock & T0Active=true & x0=tx0 & y0=ty0-> (R0Lock' = true);
	[T1R0Complete] R0Lock & T1Active=true & x0=tx1 & y0=ty1-> (R0Lock' = true);

endmodule

formula obstacleLeftR1 = (x1 = 2 & y1 = 1 & X1Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X1Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 3 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 3 & X2Y3_Occupied = true); 
formula obstacleRightR1 = (x1 = 1 & y1 = 1 & X2Y1_Occupied = true)|(x1 = 1 & y1 = 2 & X2Y2_Occupied = true)|(x1 = 1 & y1 = 3 & X2Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X3Y1_Occupied = true)|(x1 = 2 & y1 = 2 & X3Y2_Occupied = true)|(x1 = 2 & y1 = 3 & X3Y3_Occupied = true); 
formula obstacleDownR1 = (x1 = 1 & y1 = 2 & X1Y1_Occupied = true)|(x1 = 1 & y1 = 3 & X1Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y1_Occupied = true)|(x1 = 2 & y1 = 3 & X2Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y1_Occupied = true)|(x1 = 3 & y1 = 3 & X3Y2_Occupied = true); 
formula obstacleUpR1 = (x1 = 1 & y1 = 1 & X1Y2_Occupied = true)|(x1 = 1 & y1 = 2 & X1Y3_Occupied = true)|(x1 = 2 & y1 = 1 & X2Y2_Occupied = true)|(x1 = 2 & y1 = 2 & X2Y3_Occupied = true)|(x1 = 3 & y1 = 1 & X3Y2_Occupied = true)|(x1 = 3 & y1 = 2 & X3Y3_Occupied = true);

module robot1

	R1Lock : bool; // lock for clock sync
	x1 : [1..grid_size]; // location variables
	y1 : [1..grid_size];

	[release] R1Lock = true -> (R1Lock'=false); // release lock according to the sync module
	[R1Move] !R1Lock & x1>1 & !obstacleLeftR1-> (x1'=x1-1) & (R1Lock' = true); // left 
	[R1Move] !R1Lock & x1<grid_size & !obstacleRightR1-> (x1'=x1+1) & (R1Lock' = true); // right 
	[R1Move] !R1Lock & y1>1 & !obstacleDownR1-> (y1'=y1-1) & (R1Lock' = true); // down 
	[R1Move] !R1Lock & y1<grid_size & !obstacleUpR1-> (y1'=y1+1) & (R1Lock' = true); // up 

	[R1Wait] !R1Lock -> (R1Lock' = true); // wait

	[T0R1Complete] R1Lock & T0Active=true & x1=tx0 & y1=ty0-> (R1Lock' = true);
	[T1R1Complete] R1Lock & T1Active=true & x1=tx1 & y1=ty1-> (R1Lock' = true);

endmodule

module task0

	T0Active : bool;
	tx0 : [1..grid_size];
	ty0 : [1..grid_size];

	[T0R0Complete] T0Active=true & x0=tx0 & y0=ty0 -> (T0Active' = false);
	[T0R1Complete] T0Active=true & x1=tx0 & y1=ty0 -> (T0Active' = false);

endmodule

module task1

	T1Active : bool;
	tx1 : [1..grid_size];
	ty1 : [1..grid_size];

	[T1R0Complete] T1Active=true & x0=tx1 & y0=ty1 -> (T1Active' = false);
	[T1R1Complete] T1Active=true & x1=tx1 & y1=ty1 -> (T1Active' = false);

endmodule

formula all_robots_complete = (R0Lock & R1Lock);

module sync

	[release] all_robots_complete -> true;

endmodule

rewards "time"

	[release] true: 1;

endrewards

init

	R0Lock = false &
	R1Lock = false &
	T0Active = true &
	T1Active = true 
endinit